name: dbt health

on:
  schedule:
    - cron: "*/5 * * * *"   # every 5 min
  workflow_dispatch: {}

jobs:
  check-dbt:
    runs-on: ubuntu-latest
    env:
      DBT_ACCOUNT_ID: ${{ secrets.DBT_ACCOUNT_ID }}
      DBT_PROJECT_ID: ${{ secrets.DBT_PROJECT_ID }}
      DBT_TOKEN: ${{ secrets.DBT_TOKEN }}              # dbt Cloud API token (account-level)
      JOB_IDS_CSV: ${{ secrets.DBT_JOB_IDS_CSV }}      # e.g. "12345,67890"
      FAILURE_GRACE_MIN: "10"                          # ignore failures newer than N minutes to avoid flapping
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - name: Ensure incident labels exist
        uses: actions/github-script@v7
        with:
          script: |
            const core = require('@actions/core');
            const labels = ["incident","dbt"];
            for (const name of labels) {
              try {
                await github.rest.issues.getLabel({ owner: context.repo.owner, repo: context.repo.repo, name });
              } catch {
                await github.rest.issues.createLabel({ owner: context.repo.owner, repo: context.repo.repo, name, color: "B60205" });
              }
            }

      - name: Check dbt Cloud latest runs
        id: check
        run: |
          set -euo pipefail
          python - << 'PY'
          import os, sys, json, time, urllib.request
          token = os.environ["DBT_TOKEN"]
          account = os.environ["DBT_ACCOUNT_ID"]
          project = os.environ["DBT_PROJECT_ID"]
          job_ids = [j.strip() for j in os.environ["JOB_IDS_CSV"].split(",") if j.strip()]
          grace = int(os.environ.get("FAILURE_GRACE_MIN","10"))
          headers = {"Authorization": f"Token {token}", "Content-Type":"application/json"}
          base = f"https://cloud.getdbt.com/api/v2/accounts/{account}"
          failures = []
          details = []
          now = time.time()
          for jid in job_ids:
              url = f"{base}/runs/?job_definition_id={jid}&project_id={project}&order_by=-finished_at&include_related=['job']&limit=1"
              req = urllib.request.Request(url, headers=headers)
              try:
                  with urllib.request.urlopen(req, timeout=30) as r:
                      data = json.loads(r.read().decode())
              except Exception as e:
                  failures.append(jid)
                  details.append(f"job {jid}: API error {e}")
                  continue
              items = data.get("data", [])
              if not items:
                  failures.append(jid)
                  details.append(f"job {jid}: no runs found")
                  continue
              run = items[0]
              status = run.get("status")  # dbt Cloud: 10=success, 20=error, 30=cancelled
              f_at = run.get("finished_at")
              # parse finished_at to epoch (tolerate None when still running)
              finish_ts = 0
              if f_at:
                  # e.g. "2025-01-01T12:34:56Z"
                  import datetime
                  finish_ts = datetime.datetime.strptime(f_at, "%Y-%m-%dT%H:%M:%SZ").timestamp()
              # treat non-success older than grace as failure
              if status != 10 and (now - finish_ts) > grace*60:
                  failures.append(jid)
                  details.append(f"job {jid}: status {status}")
          # expose outputs
          print(f"::set-output name=failed::{','.join(failures)}")
          msg = "; ".join(details) if details else "all green"
          print(f"::set-output name=message::{msg}")
          # exit code for visibility in logs only (we handle incidents separately)
          sys.exit(0)
          PY

      # - name: Open or update incident on failure
      #   if: steps.check.outputs.failed != ''
      #   uses: actions/github-script@v7
      #   with:
      #     script: |
      #       const failed = "${{ steps.check.outputs.failed }}";
      #       const body = "dbt job failures detected: " + failed + "\n\nDetails: ${{ steps.check.outputs.message }}";
      #       const title = "dbt pipeline is degraded/outage";
      #       const { data: issues } = await github.rest.issues.listForRepo({
      #         owner: context.repo.owner, repo: context.repo.repo, labels: "incident,dbt", state: "open"
      #       });
      #       if (issues.length === 0) {
      #         await github.rest.issues.create({
      #           owner: context.repo.owner, repo: context.repo.repo,
      #           title, body, labels: ["incident","dbt"]
      #         });
      #       } else {
      #         await github.rest.issues.createComment({
      #           owner: context.repo.owner, repo: context.repo.repo, issue_number: issues[0].number,
      #           body
      #         });
      #       }

      # - name: Resolve incident when healthy
      #   if: steps.check.outputs.failed == ''
      #   uses: actions/github-script@v7
      #   with:
      #     script: |
      #       const { data: issues } = await github.rest.issues.listForRepo({
      #         owner: context.repo.owner, repo: context.repo.repo, labels: "incident,dbt", state: "open"
      #       });
      #       for (const is of issues) {
      #         await github.rest.issues.createComment({
      #           owner: context.repo.owner, repo: context.repo.repo, issue_number: is.number,
      #           body: "dbt pipeline recovered. All jobs green."
      #         });
      #         await github.rest.issues.update({
      #           owner: context.repo.owner, repo: context.repo.repo, issue_number: is.number, state: "closed"
      #         });
      #       }
